
ewpage

\chapter{Rotate Image}
\label{chap:Rotate_Image}
The "Rotate Image" problem is a classic example of a matrix manipulation challenge, commonly faced during technical interviews. The goal is to rotate a square matrix by 90 degrees clockwise, in place.

\section*{Problem Statement}
Given an \( n \times n \) two-dimensional matrix representing an image, the task is to rotate the image by 90 degrees (clockwise). The rotation must be performed in place, which means that the original matrix must be modified directly without using an additional matrix.

LeetCode link: \href{https://leetcode.com/problems/rotate-image/}{Rotate Image}

\section*{Algorithmic Approach}
To solve this problem, we can break down the rotation into two steps:
\begin{enumerate}
    \item \textbf{Transpose the matrix:} Swap the element at \texttt{matrix[i][j]} with the element at \texttt{matrix[j][i]}, for all \(i\) and \(j\) such that \(i < j\).
    \item \textbf{Flip the matrix horizontally:} Swap the element at \texttt{matrix[i][j]} with the element at \texttt{matrix[i][n-1-j]} for all \(i\) and \(j\), to achieve the clockwise rotation effect.
\end{enumerate}


\section*{Complexities}
\begin{itemize}
	\item \textbf{Time Complexity:} Since the matrix is traversed twice, once for transposing and once for flipping horizontally, the overall time complexity is \( O(n^2) \), where \( n \) is the number of rows or columns of the matrix.
	\item \textbf{Space Complexity:} As the rotation is performed in place, the space complexity is \( O(1) \), since no additional storage proportional to the input size is used.
\end{itemize}


ewpage % Start Python Implementation on a new page
\section*{Python Implementation}
Below is the complete Python code for rotating an \( n \times n \) matrix by 90 degrees clockwise in place:

\begin{fullwidth}
\begin{lstlisting}[language=Python]
def rotate(matrix):
    n = len(matrix)
    # Transpose the matrix
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    # Flip the matrix horizontally
    for i in range(n):
        for j in range(n // 2):
            matrix[i][j], matrix[i][n - 1 - j] = matrix[i][n - 1 - j], matrix[i][j]

# Example usage:
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

rotate(matrix)
print(matrix)  # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]
\end{lstlisting}

\end{fullwidth}

This implementation first transposes the matrix by swapping elements across the diagonal, and then it flips the matrix horizontally to emulate the 90 degrees clockwise rotation.

\section*{Why this approach}
This approach is chosen because of its simplicity and efficiency. By working in place, it minimizes space usage, and the operations of transposition and horizontal flipping are straightforward transformations that achieve the desired rotation.

\section*{Alternative approaches}
Alternative approaches could involve using extra space, such as creating a new matrix to hold the rotated values. However, these approaches would not satisfy the in-place requirement.

\section*{Similars problems to this one}
Similar problems include rotating a matrix by different angles, performing matrix transpositions, reflections, or other in-place operations, as well as handling non-square matrices.

\section*{Things to keep in mind and tricks}
- When addressing matrix problems, it's important to clearly visualize the index transformations occurring pre and post-rotation.
- Understand the difference between rotating clockwise and counterclockwise, as the latter may require a horizontal flip before transposing.

\section*{Corner and special cases to test when writing the code}
Consider test cases where the matrix is:
- Very small (1x1 or 2x2), as base cases might behave differently.
- Contains negative numbers or zeroes, to ensure the operations handle all value ranges.
- Very large, to ensure the algorithm performs well under stress and handles edge cases in indices properly.