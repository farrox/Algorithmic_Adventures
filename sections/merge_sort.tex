% Filename: merge_sort.tex

\problemsection{Merge Sort}
\label{problem:merge_sort}
\marginnote{Merge Sort is a fundamental divide-and-conquer algorithm that efficiently sorts arrays with a stable and predictable performance.}

The \textbf{Merge Sort} problem involves implementing the Merge Sort algorithm to sort a given array of integers in ascending order. Merge Sort is renowned for its efficiency and reliability, especially with large datasets, due to its consistent \(O(n \log n)\) time complexity.

\section*{Problem Statement}
Given an array of integers `nums`, sort the array in ascending order using the Merge Sort algorithm and return the sorted array.

\textbf{Note:} 
\begin{itemize}
    \item You must implement the Merge Sort algorithm; using built-in sorting functions is not allowed.
    \item Aim for a time complexity of \(O(n \log n)\) and a space complexity of \(O(n)\).
\end{itemize}

\textbf{Example 1:}

\begin{verbatim}
Input: nums = [5,2,9,1,5,6]
Output: [1,2,5,5,6,9]
Explanation: The array is sorted in ascending order.
\end{verbatim}

\textbf{Example 2:}

\begin{verbatim}
Input: nums = [3,0,2,5,-1,4,1]
Output: [-1,0,1,2,3,4,5]
Explanation: The array is sorted in ascending order.
\end{verbatim}

LeetCode link: \href{https://leetcode.com/problems/sort-an-array/}{Sort an Array}\index{LeetCode}

\marginnote{\href{https://leetcode.com/problems/sort-an-array/}{[LeetCode Link]}\index{LeetCode}}
\marginnote{\href{https://www.geeksforgeeks.org/merge-sort/}{[GeeksForGeeks Link]}\index{GeeksForGeeks}}
\marginnote{\href{https://www.hackerrank.com/topics/merge-sort}{[HackerRank Link]}\index{HackerRank}}
\marginnote{\href{https://app.codesignal.com/challenges/merge-sort}{[CodeSignal Link]}\index{CodeSignal}}
\marginnote{\href{https://www.interviewbit.com/problems/merge-sort/}{[InterviewBit Link]}\index{InterviewBit}}
\marginnote{\href{https://www.educative.io/courses/grokking-the-coding-interview/RM8y8Y3nLdY}{[Educative Link]}\index{Educative}}
\marginnote{\href{https://www.codewars.com/kata/merge-sort/train/python}{[Codewars Link]}\index{Codewars}}

\section*{Algorithmic Approach}
Merge Sort is a classic divide-and-conquer algorithm that divides the array into smaller subarrays, sorts them, and then merges the sorted subarrays to produce the final sorted array. The approach can be broken down into the following steps:

\begin{enumerate}
    \item \textbf{Divide:}
    \begin{itemize}
        \item Recursively split the array into two halves until each subarray contains only one element.
    \end{itemize}
    
    \item \textbf{Conquer:}
    \begin{itemize}
        \item Merge the subarrays by comparing their elements and arranging them in the correct order.
    \end{itemize}
    
    \item \textbf{Combine:}
    \begin{itemize}
        \item Continue merging the subarrays until the entire array is sorted.
    \end{itemize}
\end{enumerate}

This method ensures that the array is sorted efficiently by breaking down the problem into smaller, manageable parts and then combining them systematically.

\marginnote{Merge Sort's stable nature makes it suitable for scenarios where the relative order of equal elements needs to be preserved.}

\section*{Complexities}

\begin{itemize}
    \item \textbf{Time Complexity:} \(O(n \log n)\), where \(n\) is the number of elements in the array. This is due to the array being divided logarithmically and each division involving linear time operations during the merge process.
    \item \textbf{Space Complexity:} \(O(n)\), as additional space is required to hold the temporary arrays during the merge process.
\end{itemize}

\newpage % Start Python Implementation on a new page
\section*{Python Implementation}
\marginnote{Implementing Merge Sort requires careful handling of array indices and merging logic to ensure efficiency and correctness.}

Below is the complete Python code for the `mergeSort` function to sort an array using the Merge Sort algorithm:

\begin{fullwidth}
\begin{lstlisting}[language=Python]
class Solution:
    def mergeSort(self, nums: List[int]) -> List[int]:
        if len(nums) <= 1:
            return nums
        
        mid = len(nums) // 2
        left_half = self.mergeSort(nums[:mid])
        right_half = self.mergeSort(nums[mid:])
        
        return self.merge(left_half, right_half)
    
    def merge(self, left: List[int], right: List[int]) -> List[int]:
        sorted_list = []
        i = j = 0
        
        # Merge the two halves while comparing their elements
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                sorted_list.append(left[i])
                i += 1
            else:
                sorted_list.append(right[j])
                j += 1
        
        # Append any remaining elements from the left half
        while i < len(left):
            sorted_list.append(left[i])
            i += 1
        
        # Append any remaining elements from the right half
        while j < len(right):
            sorted_list.append(right[j])
            j += 1
        
        return sorted_list

# Example Usage:
# solution = Solution()
# print(solution.mergeSort([5,2,9,1,5,6]))  # Output: [1,2,5,5,6,9]
# print(solution.mergeSort([3,0,2,5,-1,4,1]))  # Output: [-1,0,1,2,3,4,5]
\end{lstlisting}
\end{fullwidth}

This implementation follows the classic Merge Sort algorithm:

\begin{enumerate}
    \item \textbf{Recursive Division:} The `mergeSort` function recursively divides the array into halves until subarrays of size one are reached.
    \item \textbf{Merging:} The `merge` function takes two sorted subarrays (`left` and `right`) and merges them into a single sorted array by comparing their elements.
    \item \textbf{Combining Results:} The sorted subarrays are combined step-by-step to form the final sorted array.
\end{enumerate}

\section*{Explanation}
The `mergeSort` function efficiently sorts an array by recursively dividing it into smaller subarrays and then merging those subarrays in a sorted manner. Here's a detailed breakdown of the implementation:

\begin{itemize}
    \item \textbf{Base Case:}
    \begin{itemize}
        \item If the array `nums` has one or no elements, it is already sorted. The function returns `nums` as is.
    \end{itemize}
    
    \item \textbf{Recursive Division:}
    \begin{itemize}
        \item The array is divided into two halves using the midpoint `mid`.
        \item `lefthalf` recursively calls `mergeSort` on the first half of the array.
        \item `right-half` recursively calls `mergeSort` on the second half of the array.
    \end{itemize}
    
    \item \textbf{Merging Sorted Halves:}
    \begin{itemize}
        \item The `merge` function combines `left-half` and `right-half` into a single sorted array.
        \item It iterates through both halves, comparing elements and appending the smaller one to `sorted-list`.
        \item After one half is exhausted, the remaining elements from the other half are appended to `sorted-list`.
    \end{itemize}
    
    \item \textbf{Result:}
    \begin{itemize}
        \item The merged and sorted array is returned up the recursive call stack.
        \item Eventually, the original `mergeSort` call returns the fully sorted array.
    \end{itemize}
\end{itemize}

\section*{Why This Approach}
This approach is chosen due to its consistent \(O(n \log n)\) time complexity and its ability to handle large datasets efficiently. Merge Sort's divide-and-conquer strategy ensures that the algorithm remains efficient even as the size of the input array grows. Additionally, Merge Sort is stable, meaning that it preserves the relative order of equal elements, which can be beneficial in certain applications.

\section*{Alternative Approaches}
An alternative approach to sorting arrays is the **Quick Sort** algorithm. Here's a comparison between Merge Sort and Quick Sort:

\begin{itemize}
    \item \textbf{Quick Sort:}
    \begin{itemize}
        \item \textbf{Pros:} Often faster in practice due to better cache performance; in-place sorting with \(O(\log n)\) space complexity.
        \item \textbf{Cons:} Worst-case time complexity of \(O(n^2)\) if not implemented with optimizations like random pivot selection.
    \end{itemize}
    
    \item \textbf{Merge Sort:}
    \begin{itemize}
        \item \textbf{Pros:} Consistent \(O(n \log n)\) time complexity; stable sort; well-suited for linked lists and external sorting.
        \item \textbf{Cons:} Requires additional space for merging; can be slower than Quick Sort in practice due to extra memory usage.
    \end{itemize}
\end{itemize}

While Quick Sort is often preferred for in-memory sorting due to its in-place nature and average-case efficiency, Merge Sort remains a robust choice for scenarios where stability and predictable performance are paramount.

\marginnote{Choosing the right sorting algorithm depends on the specific requirements and constraints of the problem at hand.}

\section*{Similar Problems to This One}
There are several other problems that involve sorting or manipulating arrays based on sorting algorithms, such as:
\begin{itemize}
    \item \hyperref[problem:counting_sort]{Counting Sort}\index{Counting Sort}
    \item \hyperref[problem:quick_sort]{Quick Sort}\index{Quick Sort}
    \item \hyperref[problem:heap_sort]{Heap Sort}\index{Heap Sort}
    \item \hyperref[problem:radix_sort]{Radix Sort}\index{Radix Sort}
\end{itemize}

\section*{Things to Keep in Mind and Tricks}
\begin{itemize}
    \item \textbf{Divide and Conquer:} Understanding how to break down problems into smaller subproblems can simplify complex algorithms like Merge Sort.
    \index{Divide and Conquer}
    
    \item \textbf{Handling Indices Carefully:} When dividing arrays, ensure that the indices are correctly calculated to prevent out-of-bounds errors.
    \index{Handling Indices Carefully}
    
    \item \textbf{Efficient Merging:} Optimizing the merge step can significantly impact the overall performance of the algorithm.
    \index{Efficient Merging}
    
    \item \textbf{Recursive Thinking:} Merge Sort's recursive nature requires a clear understanding of base cases and how subproblems contribute to the final solution.
    \index{Recursive Thinking}
\end{itemize}

\section*{Corner and Special Cases to Test When Writing the Code}
When implementing the `mergeSort` function, it is crucial to test the following edge cases to ensure robustness:

\begin{itemize}
    \item \textbf{Empty Array:} `nums = []` should return an empty array `[]`.
    \index{Corner Cases}
    
    \item \textbf{Single Element:} `nums = [1]` should return `[1]`.
    \index{Corner Cases}
    
    \item \textbf{Already Sorted Array:} `nums = [1,2,3,4,5]` should return `[1,2,3,4,5]`.
    \index{Corner Cases}
    
    \item \textbf{Reverse Sorted Array:} `nums = [5,4,3,2,1]` should return `[1,2,3,4,5]`.
    \index{Corner Cases}
    
    \item \textbf{Array with Duplicates:} `nums = [3,1,2,3,4,1]` should return `[1,1,2,3,3,4]`.
    \index{Corner Cases}
    
    \item \textbf{Array with Negative Numbers:} `nums = [-1, -3, -2, 0, 2, 1]` should return `[-3,-2,-1,0,1,2]`.
    \index{Corner Cases}
    
    \item \textbf{Large Input Size:} Test with a very large array to ensure that the implementation performs efficiently without exceeding memory limits.
    \index{Corner Cases}
\end{itemize}

\printindex