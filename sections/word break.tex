
ewpage

\chapter{Word Break}
\label{chap:Word_Break}
The "Word Break" problem is a classic example of a dynamic programming challenge and is often used to test one's understanding of this concept. The goal is to figure out if a given string can be segmented into a sequence of one or more words that are present in a given dictionary of words. This is not only a fundamental problem in computer science for understanding string manipulation and dynamic programming but also has practical applications in areas such as natural language processing.

\section*{Problem Statement}
Given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.

\begin{itemize}
\item The same word in the dictionary may be reused multiple times in the segmentation.
\item You are to return true if the string can be segmented, and false otherwise.
\end{itemize}

LeetCode link: \href{https://leetcode.com/problems/word-break/}{Word Break}

\section*{Algorithmic Approach}
The Word Break problem can be solved efficiently using dynamic programming. The key idea is to keep track of whether each substring of the string `s` can be segmented into words from the `wordDict`. We use an array `dp` where `dp[i]` indicates whether the substring `s[0...i)` can be segmented. The dynamic programming formula involves checking for a `j` where `dp[j]` is true and `s[j...i)` is a word in the dictionary, then setting `dp[i]` to true.

\section*{Complexities}
\begin{itemize}
	\item \textbf{Time Complexity:} The time complexity of this approach is \(O(n^2)\), where `n` is the length of the string `s`. This is because we are iterating over the substring lengths and checking each substring against the dictionary.
	\item \textbf{Space Complexity:} The space complexity is \(O(n)\) due to the extra space used to store the dynamic programming array `dp`.
\end{itemize}


ewpage % Start Python Implementation on a new page
\section*{Python Implementation}
Below is the complete Python code for solving the Word Break problem using dynamic programming:

\begin{fullwidth}
\begin{lstlisting}[language=Python]
def wordBreak(s, wordDict):
    word_set = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]

# Examples
s1 = "leetcode"
wordDict1 = ["leet", "code"]
print(wordBreak(s1, wordDict1))  # Output: true

s2 = "applepenapple"
wordDict2 = ["apple", "pen"]
print(wordBreak(s2, wordDict2))  # Output: true

s3 = "catsandog"
wordDict3 = ["cats", "dog", "sand", "and", "cat"]
print(wordBreak(s3, wordDict3))  # Output: false
\end{lstlisting}

\end{fullwidth}

The `wordBreak` function checks whether the string `s` can be segmented into words found in the `wordDict`. We use a dynamic programming approach with the array `dp`, where `dp[i]` represents whether `s[:i]` can form a word sequence.

\section*{Why this approach}
The dynamic programming approach for this problem is chosen because of its efficiency in solving problems that involve making decisions at each step based on previous results. This problem exhibits optimal substructure, where the solution can build upon the solutions to subproblems. Thus, dynamic programming is a natural fit that also avoids redundant computations seen in other methods such as backtracking or naive recursion.

\section*{Alternative approaches}
Alternative approaches to solve this problem include using recursion with memoization, which is top-down dynamic programming, or Breadth-First-Search where each node of the BFS tree represents a prefix of the string and we explore the next possible words that can be appended.

\section*{Similar problems to this one}
Similar problems that also involve dynamic programming and string manipulation include:

- LeetCode Problem 139: "Word Break II", which asks for all the possible sentence segmentations.
- LeetCode Problem 91: "Decode Ways", which involves determining the number of ways to decode a message.
  
\section*{Things to keep in mind and tricks}
When implementing the dynamic programming solution for the Word Break problem, it's important to efficiently check if a substring is in the word dictionary. Using a set data structure for the dictionary can reduce the substring lookup time to constant time. Additionally, initializing dp[0] to true allows handling the base case where no characters have been processed.

\section*{Corner and special cases to test when writing the code}
Some edge cases to consider when writing the code for this problem include:

- The string contains repeated segments (like "aaaa...") and the dictionary contains a word that could match those segments ("a"). This could result in higher time complexity if not handled appropriately.
- The string being empty or consisting of only one character.
- The dictionary being empty or containing one very long word.