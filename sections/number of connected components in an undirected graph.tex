
ewpage

\chapter{Number of Connected Components in an Undirected Graph}
\label{chap:Number_of_Connected_Components_in_an_Undirected_Graph}
The "Number of Connected Components in an Undirected Graph" problem involves finding the number of connected components in a given undirected graph considering that each node in the graph is labeled from 0 to \(n - 1\).

\section*{Problem Statement}
Given \(n\) nodes and a list of undirected edges, we need to count how many connected components exist. Each edge is represented by a pair of nodes, defining the connections in the graph.

\section*{Algorithmic Approach}
For this problem, one can utilize Depth-First Search (DFS), Breadth-First Search (BFS), or the Union-Find algorithm. These methods allow us to traverse the graph and group nodes into isolated connected components.

\section*{Complexities}
Depending on the algorithm used, the time and space complexities may vary: 

\begin{itemize}
	\item \textbf{Time Complexity:} 
      \begin{itemize}
        \item For DFS or BFS: \(O(V + E)\), where \(V\) is the number of vertices and \(E\) is the number of edges.
        \item For Union-Find: \(O(E \log V)\) in the average case with path compression.
      \end{itemize}
    \item \textbf{Space Complexity:} 
      \begin{itemize}
        \item For DFS or BFS: \(O(V)\), which is used for storing visited information and the recursion stack or queue.
        \item For Union-Find: \(O(V)\), which is needed for storing the parent and rank of each node.
      \end{itemize}
\end{itemize}


ewpage % Start Python Implementation on a new page
\section*{Python Implementation}
Below is the complete Python code using the Union-Find algorithm with path compression for finding the number of connected components in an undirected graph:

\begin{fullwidth}
\begin{lstlisting}[language=Python]
class Solution(object):
    def countComponents(self, n, edges):
        # Initialize parent and rank.
        parent = [i for i in range(n)]
        rank = [1] * n

        # Find function with path compression.
        def find(v):
            if parent[v] != v:
                parent[v] = find(parent[v])
            return parent[v]

        # Union function with union by rank.
        def union(v1, v2):
            root1, root2 = find(v1), find(v2)
            if root1 != root2:
                if rank[root1] > rank[root2]:
                    parent[root2] = root1
                    rank[root1] += rank[root2]
                else:
                    parent[root1] = root2
                    if rank[root1] == rank[root2]:
                        rank[root2] += rank[root1]

        # Process all edges and perform union operations.
        for u, v in edges:
            union(u, v)

        # Count distinct roots, which represent separate components.
        return sum(parent[i] == i for i in range(n))

# Example usage:
solution = Solution()
print(solution.countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # Output: 2
\end{lstlisting}

\end{fullwidth}

This implementation uses the Union-Find algorithm with two optimizations - path compression and union by rank. Path compression ensures that we flatten the tree structure as we perform find operations, reducing the time complexity. Union by rank guarantees that we always attach the tree with the smaller rank to the root of the tree with the larger rank, preventing skewed trees and thereby maintaining a balanced tree to minimize the time complexity of subsequent find operations.

\section*{Why this approach}
The Union-Find algorithm is particularly suited for these kinds of connectivity problems because it provides a way to efficiently query and merge components. While DFS and BFS are equally valid, Union-Find tends to be more efficient in scenarios where there are many merge operations.

\section*{Alternative approaches}
As mentioned, DFS or BFS can be used to solve this problem. Both these approaches involve visiting each vertex and all its edges, marking the visited vertices, and incrementing our count of connected components whenever starting a traversal at an unvisited vertex.

\section*{Similar problems to this one}
This problem is similar to classic Union-Find problems like "Redundant Connection," "Number of Islands," and various other problems where the connectivity within a structure is evaluated.

\section*{Things to keep in mind and tricks}
Always consider using path compression and union by rank when using the Union-Find algorithm to achieve the optimal time complexity. 

\section*{Corner and special cases to test when writing the code}
It's important to cover cases such as isolated nodes (no edges), the graph being a fully connected component (essentially one large component), and an empty graph (no nodes). Additionally, multiple edges connecting the same pair of nodes can occur and should not affect the component count.